## include 头文件 
## src 源文件 
## note 笔记

## http模块
浏览器端发送http连接请求，服务端主线程创建http对象接收请求，并将所有数据一次性读入对应buffer，
将该对象插入到任务队列，然后工作线程从队列中取出一个任务进行处理。各个子线程调用process()
函数对任务进行处理，内部分别调用process_read() process_write()分别完成报文的解析和响应

状态机逻辑
while (m_check_state == CHECK_STATE_CONTENT && line_state == LINE_OK 
                              || (line_state = parse_line()) == LINE_OK)
状态机循环入口
从状态机负责读取报文的一行，主状态机负责对该行数据进行解析
具体的，初始化主状态机为CHECK_STATE_REQUESTLINE，从状态机为LINE_OK，次状态调用解析请求头函数，如果获得完整一行，则主状态机转为CHECK_STATE_HEADER，调用解析请求头函数，通过判断内容字段是否为0，如果为0表示get请求，解析结果为GET_REQUEST，状态机结束；如果不为0为post请求，主状态机转到CHECK_STATE_CONTENT，调用解析消息体函数，完了之后从状态机状态要为LINE_OPEN防止再次进入循环。

process_write()
根据process_read对请求报文的解析结果，产生对应的响应报文(包括状态行消息头消息体)
通过iovec结构体指定响应报文的地址和长度，状态为OK的情况需要申请两个iovec，一个指向
响应报文一个指向要传输的文件，而其余状态只申请一个就行，指向响应报文

## 信号处理模块
信号采用异步处理机制，当进程收到信号后，操作系统会中断当前的进程，转而进入信号处理函数执行操作，执行完之后再返回中断的地方继续执行。
为了避免信号竞态现象发生，会设置阻塞信号集，但当信号处理函数太长会导致信号屏蔽太久，所以解决方案是信号处理函数仅仅发送信号通知主循环，而且管道写端要设置成非阻塞，万一send阻塞了信号处理函数时间又长了，然后将对应的逻辑处理放在主循环中。
信号通知采用管道的方式，信号处理函数向管道写入信号，epoll_wait从读端读取信号，然后处理具体逻辑
15s超时时间

## 日志模块
同步日志：日志写入模块会与工作线程串行执行，由于涉及到I/O操作，当单挑日志较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将下降。
异步日志：将所写的日志内容先存入阻塞队列，创建一个写线程，从阻塞队列取出内容写入日志文件。
阻塞队列：将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。主要实现两个API，push和pop。push封装生产者，用广播的方式唤醒所有消费者；pop封装消费者.

具体的，同步逻辑：构建一个string，加锁然后写文件然后解锁(如果获取不到锁，工作线程就会阻塞在这里)；异步逻辑：创建一个线程执行从阻塞队列获取一个string然后写入文件，如果没有会阻塞；主线程构建一个string，添加进阻塞队列，去唤醒阻塞在队列的线程。

## 整体构造
主循环epoll_wait监听的主要事件
- 如果是listenfd，说明其上发生了读事件 有新连接发生，执行dealclientdata(),通过accept创建一个连接，然后为该连接启动一个定时器。
- 如果发生的事件是EPOLLRDHUP | EPOLLHUP | EPOLLERR，则关闭对应的fd，删除定时器；
- 如果发生事件的文件描述符是管道读端而且事件是读事件，说明有信号触发，执行对应的信号处理函数；
- 如果事件是读事件，执行dealwith_read();
- 如果事件是些事件，执行dealwiht_write();